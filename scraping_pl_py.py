# -*- coding: utf-8 -*-
"""Scraping_PL.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vVgAqTAXpIHFgsLvlY7Bqpm7JiiR3VLN
"""

!apt-get update
!apt-get install -y chromium-browser chromium-chromedriver
!pip install selenium pandas

# Scraping sitio web fbref

!apt-get update > /dev/null
!apt-get install -y chromium-browser chromium-chromedriver > /dev/null
!pip install selenium pandas > /dev/null

import pandas as pd
import time
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from google.colab import files


# Configuraci√≥n Selenium

def init_driver():
    chrome_options = Options()
    chrome_options.add_argument("--headless")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")
    return webdriver.Chrome(options=chrome_options)

# -------------------------------
# Funci√≥n para limpiar multi√≠ndice
# -------------------------------
def flatten_columns(df):
    df.columns = [
        "_".join([str(c) for c in col if c and c != "nan"]).strip("_")
        if isinstance(col, tuple) else str(col)
        for col in df.columns.values
    ]
    return df

# -------------------------------
# Funci√≥n para extraer tablas de temporada
# -------------------------------
def get_season_data(season, league_code=9):
    """
    season: str -> '2024-2025'
    league_code: int -> 9 = Premier League
    """
    url = f"https://fbref.com/en/comps/{league_code}/{season}/stats/{season}-Premier-League-Stats"

    driver = init_driver()
    driver.get(url)
    time.sleep(5)

    tables = pd.read_html(driver.page_source, header=[0,1])
    driver.quit()

    cleaned = [flatten_columns(df) for df in tables]
    return cleaned

# -------------------------------
# Funci√≥n para filtrar m√©tricas clave (jugadores/equipos)
# -------------------------------
def select_relevant_columns(df, dataset_type="players"):
    if dataset_type == "players":
        keep = [
            "Player", "Squad", "Pos", "Age", "90s",
            "Gls", "Ast", "xG", "xA", "Sh", "SoT",
            "Cmp", "Att", "PrgP",
            "Tkl", "Int", "Blocks",
            "Won", "Lost",  # Duelos a√©reos
            "Fls", "CrdY", "CrdR",
            "Att_Drib", "Succ_Drib"
        ]
    else:  # equipos
        keep = [
            "Unnamed: 0_level_0_Squad", "MP", "W", "D", "L",
            "GF", "GA", "xG", "xGA",
            "Sh", "SoT",
            "Cmp", "Att", "PrgP",
            "Tkl", "Int", "Blocks"
        ]

    # Ensure 'Squad' column is always kept for teams
    if dataset_type == "teams" and "Unnamed: 0_level_0_Squad" not in keep:
      keep.insert(0, "Unnamed: 0_level_0_Squad")


    return df[[c for c in df.columns if any(k in c for k in keep)]]

# -------------------------------
# Script principal
# -------------------------------
seasons = ["2021-2022", "2022-2023", "2023-2024", "2024-2025"]
league_code = 9  # Premier League

all_players, all_teams = [], []

for season in seasons:
    print(f"üì• Descargando {season} ...")
    tables = get_season_data(season, league_code)

    # Tabla de jugadores (la m√°s grande suele estar en posici√≥n 2)
    players_df = select_relevant_columns(tables[2], dataset_type="players")
    players_df["Season"] = season
    all_players.append(players_df)

    # Tablas de equipos (0 = For, 1 = Against ‚Üí las unimos)
    teams_for = select_relevant_columns(tables[0], dataset_type="teams")
    teams_against = select_relevant_columns(tables[1], dataset_type="teams")

    teams = teams_for.merge(teams_against, on="Unnamed: 0_level_0_Squad", suffixes=("_For", "_Against"))
    teams["Season"] = season
    all_teams.append(teams)

# Concatenar todo
players_final = pd.concat(all_players, ignore_index=True)
teams_final = pd.concat(all_teams, ignore_index=True)

# Guardar CSVs
players_final.to_csv("players_2021_2025.csv", index=False)
teams_final.to_csv("teams_2021_2025.csv", index=False)

print("‚úÖ Archivos generados: players_2021_2025.csv y teams_2021_2025.csv")

# -------------------------------
# Descargar autom√°ticamente a tu PC
# -------------------------------
files.download("players_2021_2025.csv")
files.download("teams_2021_2025.csv")

"""Etapa 1:limpieza y transformaci√≥n del df"""

import pandas as pd


df = pd.read_csv("players_2021_2025.csv")

# Renombrar columnas
df.columns = [
    'Player', 'Pos', 'Squad', 'Age', 'Minutes_90s', 'Goals', 'Assists',
    'Yellow_Cards', 'Red_Cards', 'xG', 'npxG', 'xAG', 'npxG_xAG',
    'Prog_Passes', 'Gls_per90', 'Ast_per90', 'xG_per90', 'xAG_per90',
    'xG_xAG_per90', 'npxG_per90', 'npxG_xAG_per90', 'Season'
]

# Arreglar posiciones m√∫ltiples ‚Üí tomar solo la primera (DF,MF ‚Üí DF)
df['Pos'] = df['Pos'].apply(lambda x: x.split(',')[0] if isinstance(x, str) else x)

# Convertir columnas num√©ricas
numeric_cols = df.columns.drop(['Player', 'Pos', 'Squad', 'Season'])
df[numeric_cols] = df[numeric_cols].apply(pd.to_numeric, errors='coerce')

# Filtrar jugadores con menos de 4.5 partidos jugados (4.5 * 90 minutos)
df = df[df['Minutes_90s'] >= 4.5]

# Ver resultado
df.head()

df.info()

"""Etapa 2: Agrupacion por jugador. En esta etapa haremos un impacto acumulado por jugador, por ende jugadores con menos tiempo se ven penalizados. Se prioriza el rendimiento total


"""

# Ordenar por temporada para quedarnos con la √∫ltima edad registrada
df_sorted = df.sort_values(by="Season", ascending=True)

# Obtener edad m√°s reciente de cada jugador
edades_actuales = df_sorted.groupby("Player").last()["Age"]

# Agrupar por jugador y posici√≥n (como ya hac√≠as)
grouped = df.groupby(['Player', 'Pos']).agg({
    'Minutes_90s': 'sum',
    'Goals': 'sum',
    'Assists': 'sum',
    'Yellow_Cards': 'sum',
    'Red_Cards': 'sum',
    'xG': 'sum',
    'npxG': 'sum',
    'xAG': 'sum',
    'npxG_xAG': 'sum',
    'Prog_Passes': 'sum',
    'Gls_per90': 'mean',
    'Ast_per90': 'mean',
    'xG_per90': 'mean',
    'xAG_per90': 'mean',
    'xG_xAG_per90': 'mean',
    'npxG_per90': 'mean',
    'npxG_xAG_per90': 'mean'
}).reset_index()

# Asignar la edad correcta desde el mapeo
grouped["Age"] = grouped["Player"].map(edades_actuales)

# Guardar resumen actualizado
grouped.to_csv("jugadores_resumen.csv", index=False)

# Verificar
grouped.head()

"""Etapa 3: EDA"""

import matplotlib.pyplot as plt
import seaborn as sns

# Distribuci√≥n de jugadores por posici√≥n
sns.countplot(data=grouped, x='Pos')
plt.title('Cantidad de jugadores por posici√≥n')
plt.show()

# Edad promedio por posici√≥n
sns.boxplot(data=grouped, x='Pos', y='Age')
plt.title('Distribuci√≥n de edad por posici√≥n')
plt.show()

# Goles por 90 minutos seg√∫n posici√≥n
sns.boxplot(data=grouped, x='Pos', y='Gls_per90')
plt.title('Goles por 90 minutos seg√∫n posici√≥n')
plt.show()

"""1)Cantidad de jugadores por posici√≥n:

Hay mas jugadores registrados como DF y MF lo cual es esperable.

FW (delanteros) y GK (porteros) son menos frecuentes.

2)Distribuci√≥n de edad por posici√≥n:

Porteros (GK) tienden a tener mayor edad promedio.

Delanteros (FW) y mediocampistas (MF) tienen una edad m√°s diversa.

Buen punto para detectar promesas j√≥venes.

3)Goles por 90 minutos por posici√≥n:

Delanteros (FW) tienen claramente m√°s goles/90 min (como se espera).

Algunos MF tambi√©n destacan, podr√≠an ser mediapuntas ofensivos.

Defensas (DF) tienen un rendimiento goleador bajo.
"""

# Correlaciones entre variables num√©ricas
numeric_cols = grouped.select_dtypes(include='number').columns
correlation_matrix = grouped[numeric_cols].corr()

plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap="coolwarm")
plt.title("Matriz de correlaci√≥n")
plt.show()

"""Analisis de matriz de correlaciones
xG - Goles (xG y Goals)

Alta correlaci√≥n: confirma que los goles suelen alinearse con los goles esperados.

xAG - Asistencias

Fuerte relaci√≥n tambi√©n: buena m√©trica para identificar jugadores creativos.

Goles/90 - xG/90
Asistencias/90 - xAG/90

Esto valida que las m√©tricas por 90 minutos tienen buena correspondencia con las estad√≠sticas totales.

Pases progresivos (Prog_Passes)

Tiene relaci√≥n con xAG y Ast, ideal para detectar creadores de juego (mediocampistas creativos).

Tarjetas (amarillas y rojas)

Baja correlaci√≥n con otras m√©tricas: pueden ser usadas como penalizaci√≥n o para evaluar agresividad.

Etapa 4: el Modelo de ML
"""

from sklearn.preprocessing import StandardScaler

# Variables que usaremos para agrupar jugadores
features = [
    'Goals', 'Assists', 'xG', 'xAG', 'Prog_Passes',
    'Gls_per90', 'Ast_per90', 'xG_per90', 'xAG_per90',
    'Yellow_Cards', 'Red_Cards'
]

# Eliminar jugadores con datos faltantes en estas columnas
data_ml = grouped.dropna(subset=features).copy()

# Normalizar
scaler = StandardScaler()
X_scaled = scaler.fit_transform(data_ml[features])

from sklearn.cluster import KMeans

# Elegir cantidad de clusters (puedes ajustar luego)
k = 5
kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
data_ml['Cluster'] = kmeans.fit_predict(X_scaled)

from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)
data_ml['PCA1'] = X_pca[:, 0]
data_ml['PCA2'] = X_pca[:, 1]

# Graficar los clusters
plt.figure(figsize=(8,6))
for cluster_id in range(k):
    cluster_data = data_ml[data_ml['Cluster'] == cluster_id]
    plt.scatter(cluster_data['PCA1'], cluster_data['PCA2'], label=f'Cluster {cluster_id}', alpha=0.7)

plt.title('Clusters de jugadores (PCA)')
plt.xlabel('PCA 1')
plt.ylabel('PCA 2')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Etapa 5: Sistema de recomendacion"""

def recomendar_jugadores(df, jugador_base, edad_max=None, min_minutos=10, top_n=5):
    """
    Recomienda jugadores similares al jugador_base, del mismo cluster y misma posici√≥n.
    """

    # Verificar si el jugador base existe
    if jugador_base not in df['Player'].values:
        print(f"‚ö†Ô∏è El jugador '{jugador_base}' no se encuentra en el dataset.")
        return pd.DataFrame()

    # Obtener cluster y posici√≥n del jugador base
    jugador_row = df[df['Player'] == jugador_base].iloc[0]
    cluster_jugador = jugador_row['Cluster']
    posicion_jugador = jugador_row['Pos']

    # Filtrar por cluster y posici√≥n
    filtro = df[
        (df['Cluster'] == cluster_jugador) &
        (df['Pos'] == posicion_jugador) &
        (df['Player'] != jugador_base)
    ].copy()

    # Filtrar por edad si se especifica
    if edad_max:
        filtro = filtro[filtro['Age'] <= edad_max]

    # Filtrar por minutos
    filtro = filtro[filtro['Minutes_90s'] >= min_minutos]

    if filtro.empty:
        print("‚ö†Ô∏è No se encontraron jugadores similares con los filtros actuales.")
        return pd.DataFrame()

    # Ordenar por rendimiento ofensivo (ajustable)
    return filtro.sort_values(by='xG_xAG_per90', ascending=False).head(top_n)

jugador_base = "Kevin De Bruyne"

recomendados = recomendar_jugadores(
    df=data_ml,
    jugador_base=jugador_base,
    edad_max=None,
    min_minutos=10,
    top_n=5
)

if not recomendados.empty:
    display(recomendados[['Player', 'Age', 'Pos', 'Goals', 'xG_xAG_per90', 'Cluster']])

# Ver todos los jugadores disponibles con edad y posici√≥n
jugadores_disponibles = data_ml[['Player', 'Age', 'Pos']].drop_duplicates()
jugadores_disponibles = jugadores_disponibles.sort_values(by='Player').reset_index(drop=True)

# Mostrar
display(jugadores_disponibles)

data_ml.to_csv("jugadores.csv", index=False)

from google.colab import files
files.download("jugadores.csv")